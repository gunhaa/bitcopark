# 롬복과 최신트렌드


## @RequiredArgsConstructor(롬복)

- 막상 개발을 하면 대부분 불변이다.

- 롬복 라이브러리를 이용해서 @RequiredArgsConstructor 를 사용한다

- 해당 어노테이션은 반드시 필요한 final을 생성자에 넣는다.

- 코드가 짧아지고, 유지보수성이 늘어난다

## @Autowired

> 타입으로 조회한다<br>
> 즉, `ac.getBean(type.class)` 로 동작한다

- 만약 인터페이스의 하위타입이 전부 다 빈으로 등록되어 있다면 문제가 생긴다.

### 해결방법
1. @Autowired 필드 명 매칭
- 파라미터 이름을 우선적으로 탐색한다.
- 우선 안되고 오류만 나는 중인데 이유를 모르겠어서 skip

2. @Quilifier로 매칭
- 추가 구분자
- 구분할 수 있는 옵션을 제공한다
- @Quilifier 끼리만 매칭하는게 쓰기 편하다(안햇갈림)

```plaintext
`@Qualifier`
로 주입할 때 
`@Qualifier("mainDiscountPolicy")` 를 못찾으면 어떻게 될까? 그러면
 mainDiscountPolicy라는 이름의 스프링 빈을 추가로 찾는다. 하지만 경험상 
는 용도로만 사용하는게 명확하고 좋다
```

- @Qualifier의 기본 동작과 관련이 있다
    - 기본 동작은 1. @Qualifier끼리 매칭 , 2. 빈 이름 매칭 , 3. 예외 발생 이다.
    - 그래서 우선순위가 떨어지는 2에 쓰는것보단 1에 쓰는것이 명확하다고 표현한 것이다.


3. @Primary 사용

- 편해서 많이 사용함
- 우선 순위를 지정한다. 여러개 매칭되면 우선권을 가진다.

### @Primary vs @Qualifier

> @Primary는 기본 값처럼 동작하고, @Qualifier는 매우 상세하게 동작한다. 이런 경우 @Qualifier가 우선순위가 높고,
 대부분의 것들이 상세한 설정이 우선순위가 무조건 높다.

## 어노테이션 만들기

> Qualifier같이 파라미터로 String값이 들어가는 것은 컴파일 타임에 오류를 잡을 수 없어서 오타에 취약하다

> 애노테이션에는 상속이라는 개념이 없다. 이렇게 여러 애노테이션을 모아서 사용하는 기능은 스프링이 지원해주는 기능
이다. `@Qualifier` 뿐만 아니라 다른 애노테이션들도 함께 조합해서 사용할 수 있다. 단적으로  `@Autowired` 도 재정의 할 수 있다.
기능을 뚜렷한 목적 없이 무분별하게 재정의 하는 것은 유지보수에 더 혼란만 늘리니 지양해야한다.