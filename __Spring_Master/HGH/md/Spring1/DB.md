# DB (H2)

## db파일 생성 경로(test.mv.db)

- 별도의 경로를 지정하지 않았다면, H2는 사용자 홈 디렉터리에 파일을 저장한다. 윈도우에서 기본 경로는 보통 다음과 같다(Home의 위치)
    - `C:\Users(사용자)\YourUsername\test.mv.db`

- 첫 접속을 한 이후는 JDBC URL을 `jdbc:h2:~/test` =>`jdbc:h2:tcp://localhost/~/test` 으로 변경한다(소켓으로 접속해서, 모든곳에서 접근가능)

### 테이블 생성 예제

```sql
drop table if exists member CASCADE;
 create table member
 (
	    -- 들어온 값이 null값이라면 채워주는 설정
    id bigint generated by default as identity,
    name varchar(255),
 primary key (id)
 )
```

# 순수 JDBC

> 20년전에 개발했던 방식이다.

> 이런건 알기만하고 쓰지말자..

## `PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);` 객체의 생성 전인데 statement가 사용 가능한 이유
 
- 하위 클래스는 상위 클래스의 객체이름을 사용할 수 있으며, pstmt는 stmt의 하위 클래스이다

```java
//예제 코드
public class MyPreparedStatement extends MyStatement {
    private String sql;
    private boolean returnGeneratedKeys;

    // 생성자: SQL 쿼리와 함께 옵션을 전달받음
    public MyPreparedStatement(String sql, int autoGeneratedKeys) {
        super(sql);  // MyStatement의 생성자 호출
        this.sql = sql;
        this.returnGeneratedKeys = (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS);
    }

    // 실행되는 SQL 쿼리의 실행
    public int executeUpdate() throws SQLException {
        System.out.println("Executing SQL: " + sql);
        if (returnGeneratedKeys) {
            System.out.println("Return generated keys.");
        }
        // 실제 SQL 실행 코드 (간단화)
        return 1;  // 예시로 1을 반환
    }

    // 자동 생성된 키 반환
    public ResultSet getGeneratedKeys() {
        if (returnGeneratedKeys) {
            return new MyResultSet();
        }
        return null;
    }
}

class MyStatement {
    private String sql;

    public MyStatement(String sql) {
        this.sql = sql;
    }

    // 일반적인 Statement 클래스에서 사용하는 메서드
    public int executeUpdate() throws SQLException {
        System.out.println("Executing SQL: " + sql);
        return 0;
    }
}

class MyResultSet {
    // 간단히 ResultSet을 반환하는 예시 클래스
    public void printGeneratedKeys() {
        System.out.println("Generated key: 12345");
    }
}
```

### 객체가 생성되기 전에 그 객체를 생성자에 넣어서 설정용으로 쓸수있다

1. 객체 생성과 초기화 과정
객체 지향 프로그래밍에서 객체는 생성자를 통해 초기화된다. 객체가 생성되면 생성자 내에서 객체의 상태를 설정하거나 초기화할 수 있다. 이때 생성자에 파라미터를 전달하여 객체를 설정할 수 있다.

2. 객체 생성이 이루어지기 전에 파라미터로 전달이 가능한 이유
이것은 사실 객체 생성 후에 일어나는 일이지만, 객체가 생성되는 시점에 파라미터로 값을 전달하여 객체의 상태를 결정하는 방식이다. 생성자에서 초기화하는 작업은 객체 생성과 동시에 일어나는 것이므로, 객체가 "생성된 후"라기보다는 "생성되면서" 값을 설정하는 방식이다.

3. 생성자에서 파라미터를 사용하여 객체 설정
객체는 new 키워드를 사용하여 생성되며, 생성자에 파라미터를 전달할 수 있다. 이 파라미터를 통해 객체의 초기 상태를 설정하거나, 객체를 초기화할 수 있습니다. 그 말은 객체 생성과 초기화가 동시에 이루어질 수 있다는 것다.

#### 정적 상수 예시코드
```java
// Device 클래스: 장치를 나타내는 클래스
class Device {

    // 장치 상태를 나타내는 정적 상수
    public static final int ON = 1;   // 장치가 켜져 있는 상태
    public static final int OFF = 0;  // 장치가 꺼져 있는 상태

    // 현재 장치 상태 (ON/OFF)
    private int state;

    // 생성자: 장치의 초기 상태를 OFF로 설정
    public Device() {
        this.state = OFF;  // 기본 상태는 OFF
    }

    // 장치의 상태를 변경하는 메서드
    public void setState(int state) {
        if (state == ON) {
            this.state = ON;
            System.out.println("The device is now ON.");
        } else if (state == OFF) {
            this.state = OFF;
            System.out.println("The device is now OFF.");
        } else {
            System.out.println("Invalid state.");
        }
    }

    // 장치 상태 출력 메서드
    public void printState() {
        if (this.state == ON) {
            System.out.println("The device is currently ON.");
        } else {
            System.out.println("The device is currently OFF.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        // Device 객체 생성
        Device myDevice = new Device();

        // 초기 상태 출력 (OFF)
        myDevice.printState();

        // 장치 상태를 ON으로 변경
        myDevice.setState(Device.ON);
        myDevice.printState();

        // 장치 상태를 OFF로 변경
        myDevice.setState(Device.OFF);
        myDevice.printState();
    }
}
```

## ** JDBC를 통해서 해본 OCP를 이용한 설계 

![db1](../../images/db1.png)

- 코드 한줄만 변경한 것으로, 인터페이스의 구현체를 바꿔 낄 수 있다.

## 테스트코드 작성

> 이전까지의 테스트는 자바(JVM)만을 이용한 테스트

> Spring을 사용한 테스트 방법은 조금 다르다

- `@SpringBootTest` 와 `@Transactional` 어노테이션을 사용해야한다.

- `@SpringBootTest` : 스프링 컨테이너와 함께 테스트를 실행한다.

- `@Transactional` : 이 어노테이션이 있어야 스프링이 Rollback을 실행시켜서 지속가능한 테스트가 가능해진다.

### 단위테스트와 통합테스트

> DB와 연결되어서 전체적인 테스트가 통합테스트, 코드만을 이용한 테스트가 단위테스트

- 일반적인 경우 단위테스트가 통합테스트보다 훨씬 좋은 방법이다.

# 스프링 JdbcTemplate

> 순수 Jdbc와 동일한 환경설정을 하면 된다. 

> 스프링 JdbcTemplate과 MyBatis 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분 제거해준다. 하지만 SQL은 직접 작성해야 한다

> 실제로 많이 사용한다.

## 사용법
```java
public class JdbcTemplateMemberRepository implements MemberRepository{

    private final JdbcTemplate jdbcTemplate;

    // @Autowired 생성자가 1개라면 생략 가능
    public JdbcTemplateMemberRepository(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }
```

rowmapper 메소드
```java
// 람다로 바꾸기 전
    private RowMapper<Member> memberRowMapper(){
        return new RowMapper<Member>() {
            @Override
            public Member mapRow(ResultSet rs, int rowNum) throws SQLException {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return member;
            }
        }
    }
// 람다식
    private RowMapper<Member> memberRowMapper(){
        return (rs, rowNum) -> {
            Member member = new Member();
            member.setId(rs.getLong("id"));
            member.setName(rs.getString("name"));
            return member;
        }
    }
```
### 이 코드가 가능한이유? 무슨 코드인가?

1. RowMapper 인터페이스
RowMapper는 JDBC에서 ResultSet을 자바 객체로 변환할 때 사용하는 인터페이스이다. RowMapper는 mapRow()라는 추상 메서드를 가지고 있으며, 이 메서드는 데이터베이스에서 반환된 각 행(row)을 객체로 변환하는 방법을 정의한다.

```java
public interface RowMapper<T> {
    T mapRow(ResultSet rs, int rowNum) throws SQLException;
}
//ResultSet rs: 데이터베이스에서 조회된 한 행의 결과를 나타낸다.
//int rowNum: 현재 처리 중인 행 번호로, 주로 RowMapper 구현에서 필요하지 않지만, 일부 경우에 사용할 수 있다.
```
- 반환 타입: mapRow()는 T 타입의 객체를 반환한다. T는 RowMapper를 구현할 때 지정된 타입 파라미터이다. 예를 들어, RowMapper<Member>로 지정하면 mapRow()는 Member 객체를 반환해야 한다.

2. 람다식을 사용하는 이유
람다식은 메서드를 한 줄로 구현할 수 있는 간결한 방식이다. 람다식은 인터페이스의 추상 메서드를 구현하는 데 사용된다. RowMapper에서 mapRow() 메서드는 추상 메서드이므로 람다식으로 쉽게 구현할 수 있다.

람다식으로 mapRow() 메서드 구현
람다식을 사용하여 mapRow() 메서드를 구현할 수 있다. 예를 들어, 다음과 같이 ResultSet의 각 행을 Member 객체로 변환하는 람다식 구현이 가능하다

```java
private RowMapper<Member> memberRowMapper() {
    return (rs, rowNum) -> {
        Member member = new Member();
        member.setId(rs.getLong("id"));
        member.setName(rs.getString("name"));
        return member;
    };
}
```
3. 왜 mapRow()가 사용되는가?
람다식으로 RowMapper를 구현하면 mapRow() 메서드가 RowMapper 인터페이스에서 요구하는 메서드이기 때문에 **JdbcTemplate이나 NamedParameterJdbcTemplate**과 같은 JDBC 템플릿 라이브러리에서 자동으로 호출된다. 이 메서드는 ResultSet을 자바 객체로 변환하는 역할을 한다.

4. 결론
람다식으로 RowMapper를 구현하면, 실제로는 mapRow() 메서드가 RowMapper 인터페이스에서 요구하는 메서드이기 때문에 자동으로 호출된다. 람다식은 단순히 mapRow() 메서드의 구현을 간결하게 표현한 것이다. 람다식의 동작은 기본적으로 mapRow() 메서드가 RowMapper 인터페이스의 요구사항에 맞게 호출되는 방식과 동일하다.

#### 반환형이 인터페이스라면?
- 반환형이 인터페이스일 때, 그 메서드는 인터페이스를 구현한 클래스의 인스턴스를 반환해야 한다.
- 람다식은 인터페이스를 구현한 클래스의 익명 객체를 간결하게 반환하는 방법이다.
- 메서드가 반환하는 객체는 인터페이스가 아닌 구체적인 구현체이어야 하며, 람다식은 이 구현체를 간단히 표현하는 방법이다.