# CPU 스케줄링 (CPU Scheduling)
여러 프로세스 중에서 어떤 프로세스가 CPU를 사용할지 결정하는 과정

CPU 스케줄링 알고리즘


<details>
<summary><h3>FCFS (First-Come, First-Served) - 선입선출</h3></summary>

개념:
- FCFS는 가장 기본적인 CPU 스케줄링 알고리즘으로, 프로세스가 도착한 순서대로 CPU를 할당합니다. 먼저 도착한 프로세스가 먼저 실행됩니다.  
- 대기 중인 프로세스는 큐에 저장되고, CPU가 사용될 때 순차적으로 실행됩니다.

예시:
프로세스|도착 시간|실행 시간 (CPU 버스트)
---|---|---
P1|0|5
P2|1|3
P3|2|8
P4|3|6

동작 과정:
1. P1이 0초에 도착하여 먼저 실행 (5초 소요)
2. P2는 1초에 도착하지만, P1이 끝날 때까지 기다림 (3초 소요)
3. P3은 2초에 도착하고, 5초에 CPU를 받음 (8초 소요)
4. P4는 3초에 도착하고, 13초에 실행됨 (6초 소요)

실행 순서: P1 → P2 → P3 → P4

장점:
- 구현이 간단하고, 공정합니다.

단점:
- 긴 프로세스가 앞에 오면 뒤의 프로세스들이 대기 시간이 길어질 수 있어 기아 현상(starvation)이 발생할 수 있습니다.
- 응답 시간이 길어질 수 있습니다.
</details>

<details>
<summary><h3>SJF (Shortest Job First) - 최단 작업 우선</h3></summary>

개념:
- SJF는 실행 시간이 가장 짧은 프로세스부터 먼저 실행하는 알고리즘입니다.
- 비선점형 방식으로, 프로세스가 완전히 실행될 때까지 CPU를 독점합니다.

예시:
프로세스|도착 시간|실행 시간 (CPU 버스트)
---|---|---
P1|0|6
P2|1|8
P3|2|7
P4|3|3

동작 과정:
1. P1은 0초에 도착하고 실행 시간 6초로 첫 번째로 실행됩니다.
2. P2, P3, P4가 도착하지만, P4는 3초에 도착하여 실행 시간이 가장 짧고 3초로 두 번째로 실행됩니다.
3. 그 후 P3이 7초로 세 번째로 실행되고, 마지막으로 P2가 실행됩니다.

실행 순서: P1 → P4 → P3 → P2

장점:
- 대기 시간을 최소화하는 효과가 있습니다.
- 짧은 작업이 빨리 처리되어 응답 시간이 짧습니다.

단점:
- 긴 작업이 대기할 가능성이 높고, 기아 현상이 발생할 수 있습니다.
- 실행 시간 예측이 어려운 경우가 많아 실용성에 한계가 있을 수 있습니다.
</details>

<details>
<summary><h3>RR (Round Robin) - 라운드 로빈</h3></summary>

개념:
- RR은 프로세스에 CPU 시간을 공평하게 분배하기 위해, 각 프로세스에 타임 퀀텀(예: 4초)을 주고, 주어진 시간 내에 실행되지 않은 프로세스는 큐의 끝으로 돌아갑니다.
- 모든 프로세스가 동등한 기회를 가지며 선점형입니다.

예시:
프로세스	도착 시간|실행 시간|(CPU 버스트)
---|---|---
P1|0|5
P2|1|3
P3|2|8
P4|3|6

동작 과정 (타임 퀀텀 4초):
1. P1이 0초에 도착하여 4초 동안 실행, 1초가 남아 대기 큐로 돌아갑니다.
2. P2는 1초에 도착하여 3초 동안 실행되며 종료됩니다.
3. P3는 2초에 도착하여 4초 동안 실행되고, 4초가 남아 다시 대기 큐로 돌아갑니다.
4. P4는 3초에 도착하여 4초 동안 실행되고, 2초가 남아 다시 대기 큐로 돌아갑니다.
5. P1이 다시 4초에 돌아와 1초를 실행하고 종료됩니다.
6. P3는 다시 돌아와 나머지 4초를 실행하고 종료됩니다.
7. 마지막으로 P4가 2초를 실행하고 종료됩니다.

실행 순서: P1 → P2 → P3 → P4 → P1 → P3 → P4

장점:
- 공정하게 CPU 자원을 분배하여 모든 프로세스가 일정 시간 CPU를 사용할 수 있게 합니다.
- 대화형 시스템에 적합하여 빠른 응답을 제공합니다.

단점:
- 컨텍스트 스위칭이 자주 발생하여 오버헤드가 커질 수 있습니다.
- 타임 퀀텀이 너무 크거나 작으면 성능이 떨어질 수 있습니다.
</details>

<details>
<summary><h3>Priority Scheduling - 우선순위 스케줄링</h3></summary>

개념:
- 프로세스는 우선순위에 따라 CPU 자원을 할당받습니다. 높은 우선순위를 가진 프로세스는 먼저 실행됩니다.
- 이 알고리즘은 선점형(preemptive) 또는 비선점형(non-preemptive)으로 구현할 수 있습니다.

예시:
프로세스|도착 시간|실행 시간 (CPU 버스트)|우선순위
---|---|---|---
P1|0|4|3
P2|1|3|1
P3|2|2|4
P4|3|5|2

동작 과정 (우선순위가 낮을수록 높은 우선순위):
1. P3은 우선순위가 가장 높아서 첫 번째로 실행됩니다.
2. 그 후 P1, P4, P2가 우선순위대로 실행됩니다.

실행 순서: P3 → P1 → P4 → P2

장점:
- 중요한 프로세스는 먼저 실행되어 긴급한 작업을 빠르게 처리할 수 있습니다.

단점:
- 기아 현상(Starvation) 문제: 낮은 우선순위의 프로세스는 계속 대기할 수 있습니다.
</details>

<details>
<summary><h3>Shortest Remaining Time First (SRTF) - 최단 남은 시간 우선 스케줄링 (선점형)</h3></summary>

개념:
- SRTF는 SJF 알고리즘의 선점형 버전입니다.
- 프로세스가 실행되는 도중에도 남은 실행 시간이 더 짧은 프로세스가 새로 도착하면, 현재 실행 중인 프로세스가 중단되고 새로 도착한 프로세스가 CPU를 차지합니다.

예시:
프로세스|도착 시간|실행 시간 (CPU 버스트)
---|---|---
P1|0|5
P2|1|3
P3|2|7
P4|3|4

동작 과정:
1. P1이 0초에 도착하여 실행되기 시작합니다.
2. P2가 1초에 도착하고 남은 시간인 3초가 더 짧기 때문에 P1은 멈추고 P2가 실행됩니다.
3. P3이 2초에 도착하지만, P2가 먼저 실행됩니다.
4. P4는 3초에 도착하지만, P2가 먼저 끝나고 P1이 다시 실행됩니다.

실행 순서: P1 → P2 → P4 → P1 → P3

장점:
- 기다리는 프로세스의 대기 시간을 최소화합니다.
- CPU 시간이 짧은 프로세스를 빠르게 실행시켜 효율적입니다.

단점:
- 컨텍스트 스위칭이 자주 발생하여 오버헤드가 커질 수 있습니다.
- 기아 현상이 발생할 수 있습니다.
</details>

<details>
<summary><h3>Multilevel Queue Scheduling - 다단계 큐 스케줄링</h3></summary>

개념:
- Multilevel Queue Scheduling은 여러 개의 큐를 사용해 각 큐에 우선순위나 프로세스 유형에 따라 프로세스를 분류하여 처리합니다.
- 각 큐는 다른 스케줄링 알고리즘을 사용할 수 있습니다.
- 예를 들어, 우선순위 큐와 배치 큐가 있을 때, 우선순위 큐의 프로세스가 먼저 실행됩니다.
- 각 큐 간에 프로세스 이동은 없습니다.

예시:
프로세스|도착 시간|실행 시간 (CPU 버스트)|큐
---|---|---|---
P1|0|4|큐 1
P2|1|3|큐 2
P3|2|5|큐 1
P4|3|2|큐 2
- 큐 1: 우선순위가 높은 프로세스 (예: 인터랙티브 프로세스)
- 큐 2: 우선순위가 낮은 프로세스 (예: 배치 프로세스)

동작 과정:
1. 큐 1이 우선 실행됩니다. P1이 먼저 실행되고, P3이 그 뒤를 이음.
2. 큐 1의 프로세스들이 끝나면 큐 2의 프로세스들이 실행됩니다. P2와 P4가 실행됩니다.

실행 순서: P1 → P3 → P2 → P4

장점:
- 프로세스를 우선순위와 타입에 맞게 효율적으로 관리합니다.

단점:
- 기아 현상이 발생할 수 있습니다.
- 큐 간 이동이 없기 때문에 유연성이 떨어질 수 있습니다.
</details>

<details>
<summary><h3>Multilevel Feedback Queue Scheduling - 다단계 피드백 큐 스케줄링</h3></summary>

개념:
- Multilevel Feedback Queue Scheduling은 Multilevel Queue의 확장판으로, 프로세스가 큐 간에 이동할 수 있게 합니다.
- 프로세스가 처음에는 높은 우선순위 큐에서 시작하여, CPU 버스트가 긴 프로세스는 낮은 우선순위 큐로 내려갑니다.
- 이 방식은 프로세스의 특성에 따라 적응하며, 기아 현상을 방지할 수 있습니다.

예시:
프로세스|도착 시간|실행 시간 (CPU 버스트)
---|---|---
P1|0|2
P2|1|5
P3|2|7
P4|3|3
- 큐 1: 높은 우선순위 (빠른 CPU 버스트를 가진 프로세스)
- 큐 2: 낮은 우선순위 (긴 CPU 버스트를 가진 프로세스)

동작 과정:
1. 처음에는 큐 1에서 실행됩니다. P1이 빠르게 실행되고 종료됩니다.
2. P2가 큐 1에서 실행되고, 남은 시간이 길어지면 큐 2로 이동하여 계속 실행됩니다.
3. P3도 마찬가지로 큐 1에서 실행 후 큐 2로 이동합니다.

실행 순서: P1 → P2 → P3 → P4

장점:
- 기아 현상을 방지하고, 동적 적응을 통해 다양한 프로세스를 효율적으로 처리할 수 있습니다.

단점:
- 구현이 복잡하며, 큐 관리에 대한 오버헤드가 발생할 수 있습니다.

</details>

<details>
<summary><h3>Lottery Scheduling - 복권 스케줄링</h3></summary>

개념:
- Lottery Scheduling은 무작위 추첨을 통해 CPU를 할당하는 방식입니다.
- 각 프로세스는 복권 티켓을 얻고, 추첨을 통해 CPU를 할당받습니다. 많은 티켓을 가진 프로세스가 더 자주 CPU를 할당받을 가능성이 높습니다.
- 이 방식은 확률적으로 CPU를 할당하므로 간단하고 공정한 방법으로 구현할 수 있습니다.

예시:
프로세스|도착 시간|실행 시간 (CPU 버스트)|티켓 수
P1|0|4|5
P2|1|3|1
P3|2|2|3
P4|3|5|6

동작 과정:
- 각 프로세스는 티켓을 부여받고, 일정 시간마다 추첨을 통해 CPU가 할당됩니다.
- P4가 가장 많은 티켓을 가지고 있으므로, P4가 CPU를 받을 확률이 높습니다. 하지만 랜덤이기 때문에 P1이나 P3도 CPU를 할당받을 수 있습니다.

장점:
- 구현이 간단하고 공정성을 제공합니다.
- 우선순위가 동적으로 조정되며, 확률적으로 처리됩니다.

단점:
- 예측할 수 없는 결과가 나오기 때문에 성능에 예기치 않은 영향을 미칠 수 있습니다.
- 컨텍스트 스위칭이 자주 발생할 수 있습니다.

</details>
